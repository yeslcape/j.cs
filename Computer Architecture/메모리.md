# 메모리

### 메모리 필요 이유
프로그램이 실행되기 위해서는 먼저 프로그램이 메모리에 로드(load) 되어야 함.
프로그램에서 사용되는 변수들을 저장할 메모리 필요

### 메모리 공간
![img_c_memory_structure](https://github.com/yeslcape/j.cs/assets/45252618/ba90bafd-ab68-441a-ab59-f55e09e66b03)
1. 코드(code) 영역
   * 실행할 프로그램의 코드가 저장되는 영역
   * CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리
2. 데이터(data) 영역
   * 프로그램의 전역 변수와 정적 변수 저장되는 영역
   * 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸
3. 스택(stack) 영역
   * 함수의 호출과 관계되는 지역 변수와 매개 변수가 저장되는 영역
   * 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸
   * FIFO 방식으로 동작하여, 가장 늦게 저장된 데이터가 가장 먼저 인출됨
   * 메모리의 높은 주소에서 낮은 주소의 방향으로 할당
   * 컴파일 타임에 크기 결정
     * cf) 컴파일 타임 : 소스코드가 실행가능한 기계어코드로 변환되어 머신에서 실행가능한 프로그램이 되는 타임
4. 힙(heap) 영역
   * 사용자가 직접 관리할 수 있고, 관리해야만 하는 메모리 영역
   * 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됨
   * 메모리의 낮은 주소에서 높은 주소의 방향으로 할당
   * 런타임에 크기 결정 (동적할당)
     * cf) 런타임 : 컴파일 과정을 마친 프로그램이 사용자에 의해 실행되고 응용프로그램이 동작하는 시점

cf) 오버플로우(overflow) : 힙과 스택의 메모리가 채워지는 방향성이 달라서 프로그램이 돌다보면 어느순간 두 영역이 서로의 영역을 침범하게 되면 발생하는 에러

### 메모리 특징
* 시간적 지역성: 한 번 참조되면 곧바로 다시 참조되기 쉬운 특성
* 공간적 지역성: 어떤 내용이 참조되면 그 내용에 가장 가까운 곳에 있는 다른 내용이 곧바로 참조되기 쉬운 특성
* 기억장치는 지역성의 원리를 이용하여 계층으로 구성
* 계층의 순서 : 레지스터(CPU), 캐시기억장치(CPU), 주기억장치(메모리), 보조기억장치(하드디스크) 
* 위로 올라갈수록 접근시간 감소, 속도 증가, 비용 비싸짐, 용량 적어짐

### 메모리 계층 구조
![image](https://github.com/yeslcape/schedule/assets/45252618/5a8cbc0c-80e9-4092-af5a-16f88f21d776) 
* 메모리를 필요에 따라 여러 가지 종류로 나누어 둠
1. 레지스터
   * CPU 내부에서 명령어 또는 연산을 처리하면서 발생하는 데이터를 일시적으로 저장하는 기억장치
   * 주기억장치(RAM)보다 저장용량 작지만, 처리속도 가장 빠름
   * 가격 비쌈
   * 크기 작음
   * 여러 개의 Flip Flop 이나 Latch 등을 연결하여 구성
   * 휘발성 메모리
   * 읽고 쓰기 가능
2. 캐시 메모리
   * CPU와 메인 메모리 간의 데이터 속도 향상을 위한 중간 버퍼 역할을 해주는 CPU 내부에 존재하는 메모리
   * 사용되었던 데이터는 다시 사용되어질 가능성이 높다는 개념을 이용하여, 다시 사용될 확률이 높은 것은 더 빠르게 접근할 수 있도록 하는 저장소를 사용한다는 개념
   * 빠른 장치와 느린 장치 사이의 속도 차이에 따른 병목 현상을 줄이기 위한 메모리
3. 주기억장치(메인 메모리)
   * 컴퓨터에서 수치, 명령, 자료 등을 기억하는 컴퓨터 하드웨어 장치
   * CPU나 메인보드와 분리되어 있는 메모리 중에서는 최상위 메모리이자, 프로그램을 직접 구동하는 데 사용되는 '주 기억 장치'의 최하위 메모리
   * CPU와 캐시에 비하면 훨씬 느리지만, HDD는 말할 것도 없고 SSD에 비해서도 차원이 다르게 빠름
4. 보조기억장치(하드 디스크)
   * 비휘발성
   * 순차접근이 가능한 보조 기억 장치

| 명칭  | 위치                   | 접근 속도                      |
|-----|----------------------|----------------------------|
| 레지스터| CPU 내부               | 빠름                         |
| 캐시  | CPU 내부               | 빠름                         |
| 메인 메모리| CPU 외부(CPU 직접 접근 가능) | 레지스터와 캐시보다는 느림             |
| 하드디스크| CPU 직접 접근 불가 | 느림(데이터를 메인메모리에 이동시켜 접근 가능) |

* 구조 형성 이유
  * 레지스터만으로 고용량을 구성할 경우 많은 비용 초래
  * 가장 많이 쓰는 작업을 상단에 두고, 적게 쓰는 작업을 하단에 두는 식으로 동작하여 효율적인 성능 발휘
  * CPU는 처음에 레지스터에서 프로그램을 찾고, 없다면 캐시, 그 이후에는 메모리에서 찾는 식으로 역할 수행

<br><br><br>
Reference
- https://www.tcpschool.com/c/c_memory_structure
- https://velog.io/@rsuubinn/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0-%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%EC%A1%B0-CPU%EC%99%80-%EB%A9%94%EB%AA%A8%EB%A6%AC
- https://velog.io/@ssssujini99/CS%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0%EB%8F%84-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%BA%90%EC%8B%9C-%EB%A9%94%EB%AA%A8%EB%A6%ACCache-memory
- https://namu.wiki/w/%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B3%84%EC%B8%B5%20%EA%B5%AC%EC%A1%B0
- https://velog.io/@ajm0718/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0